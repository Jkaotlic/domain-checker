# Техническая документация проекта

**Overview**

- **Проект**: набор сервисов/утилит для поиска поддоменов и обратного поиска по IP (reverse DNS), агрегирования данных из пассивных источников и оценки (scoring) достоверности найденных поддоменов.
- **Ядро**: Next.js + TypeScript с серверными API-роутами в . Основная логика — в каталоге .
- **Назначение**: принимать запросы на проверку домена или текст с IP, собирать поддомены/хосты из разных источников, кешировать результаты и возвращать нормализованный ответ.

**Архитектура (вкратце)**

- Клиент → API роуты:
  -  → 
  -  → 
- API использует:
  - fetch/HTTP клиенты с retry: 
  - DNS/ptr/resolve: 
  - Адаптеры пассивных источников:  → 
  - Кеш:  и 
  - Агрегация/мёрдж/апдейт записей: 
  - Нормализация/валидаторы хостов: 
  - Оценка качества (score): 
- Хранилище: In-memory LRU по умолчанию; при наличии  используется  (реализация `ioredis` в ).

Простой ASCII-диаграм:
client -> [app/api/check] -> aggregator -> passiveSources -> fetchWithRetry
                                     ↘ cache (lib/cache)
client -> [app/api/reverse] ->  -> cache

**Компоненты (файлы и роли)**

- Конфигурация
  - : центральные таймауты, TTL и константы (). Используется везде.

- API routes
  - : основной маршрут проверки домена.
    - Алгоритм: нормализация домена → пробует активные проверочные запросы к списку популярных поддоменов () → собирает результаты от пассивных источников (crt.sh, HackerTarget, urlscan, AlienVault через ) → объединяет, резолвит A-записи при необходимости → кеширует агрегированный результат в .
  - : маршрут обратного поиска (reverse DNS).
    - Алгоритм: парсит тела (список IP/текст с командами) → валидирует IP → использует  и  → возвращает результаты и статистику.

- Сеть и утилиты
  - : HTTP клиент с retry/backoff, поддержкой `Retry-After`, per-host concurrency (p-limit).
    - Экспорт: .
  - [lib/net/worker.ts]: вспомогательный раннер задач (используется для контролируемой параллельности). (см. исходник)

- Пассивные источники
  - : фасад для источников.
  - Реализации:
    - 
    - 
    - 
    - 
  - Все используют  и нормализуют/фильтруют ответы в виде массива поддоменов.

- Кеширование и Redis
  - : фабрика кеша :
    - по умолчанию  (LRU cache).
    - при  пытается инициализировать  (в ) — проект уже содержит  с реальной `ioredis` и вспомогательными /.
  -  (в папке ): (в репо есть stub/реализации) — посмотреть, если нужно полноценно включать Redis.

- Агрегация / нормализация / дедуп
  - :
    - , ,  — логика объединения записей поддоменов: union IP, union tags/sources, merge timestamps.
    - Использует  и per-key in-flight dedupe (Map of promises).

- Scoring
  - :
    - : подсчитывает нормализованный скор (0..1) на основе веса источников, частоты, DNS-consistency, PTR-evidence и штрафов за suspicious tags.
    -  возвращает bucket ('high'|'medium'|'low').

- DNS & Reverse utilities
  - :
    - , , , , .
    - Поведение: пытается , затем crt.sh fallback, кеширует результаты, поддерживает timeouts и batching.

- Subdomain normalisation/validation
  - :
    - ,  — использует  и .

- Логирование / Метрики
  - [lib/logger.ts], [lib/metrics.ts] — небольшие обёртки для логирования/счётчиков (см. исходники при необходимости).

**API routes — подробности**

-  — 
  - Вход: JSON { domain: string }
  - Выход: { domain, subdomains: [{ subdomain, ips, source }], total }
  - Порядок действий: normalize → active/common subdomain checks (DNS A lookup) → параллельно crt.sh + passiveSources → merge/dedupe → cache .
  - Ключи кеша:  (см. код).

-  — 
  - Вход: JSON { text: string, maxIPs?: number }
  - Парсит команды  и простые строки IP; возвращает массив по каждому IP: hostnames + optional error.
  - Использует  +  с ключами .

**Data flows (описание шагов)**

1. Client отправляет  с доменом.
2.  нормализует домен и сразу делает:
   - Проверку "основного" домена через DNS ( в ).
   - Параллельную проверку списка популярных поддоменов.
   - Параллельный запрос в пассивные источники (через  → ).
   - Резолв A-записей для найденных субдоменов (если возможно).
3. Результаты объединяются в , приоритет — записи с IP.
4. Отправка результата клиенту и запись в кеш через .

Reverse flow:
1. Client отправляет текст в .
2. IP извлекаются () → параллельно  для каждого IP → результаты кешируются и возвращаются.

**Кеширование & Redis**

-  выбирает адаптер:
  - если  задан — пытается инициализировать  (основан на `ioredis`, , , ).
  - иначе —  (LRU).
- TTL берутся из  ().
- Рекомендуем: включать Redis в production, чтобы кластеры/перезапуски не обнуляли кеш.

**Пассивные источники**

- Фасад: 
- Источники:
  - `securitytrails` требует .
  - `urlscan`, `hackertarget`, `alienvault` — публичные API, но некоторые имеют rate-limit/ключи.
- Все запросы идут через  для корректной обработки таймаутов и 5xx/429.

**Scoring и reverse lookups**

-  в  — многофакторная формула (источник, частота, DNS consistency, PTR, штрафы).
-  в  — сначала , затем crt.sh fallback; кеширование PTR результатов.

**Запуск & тестирование**

- Предположения:
  - В  есть стандартные скрипты (`dev`, `build`, `start`, ). (Если нет — сообщите, подскажу команды).
  - Тесты — Jest (есть  и  папка).
- Общие команды (предполагаемые):
  - Установить зависимости:
    - npm install
  - Локальная разработка:
    - npm run dev
  - Сборка:
    - npm run build
  - Тесты:
    - npm test
- Для запуска с Redis: установить Redis и экспортировать  (например `redis://localhost:6379`).

Примеры переменных окружения:
-  — URL Redis (опционально)
-  — пароль Redis
-  — API ключ SecurityTrails
- , , ,  — можно переопределять через env (см. ).

**Extending the project (как добавить источник / улучшить)**

- Добавить новый пассивный источник:
  1. Создать `lib/sources/<provider>.ts` с экспортом по умолчанию -> функцию `fetchX(domain): Promise<string[]>`.
  2. Зарегистрировать в  и экспортировать wrapper `getFromNewSource`.
  3. В  добавить вызов нового `getFrom...`.
- Подключение реального Redis:
  - Реализовать/доработать  (если требуется более тонкая интеграция) и убедиться, что  возвращает адаптер Redis.
- Добавление новых полей в scoring:
  - Обновить  и логику  в .

**Troubleshooting / типичные проблемы**

- Пассивные источники возвращают пусто:
  - Проверьте ключи API (например ) и rate-limits.
- Redis не используется:
  - Убедитесь, что  корректен и доступен; см.  в  — он делает  при инициализации.
- Ошибки таймаута/429:
  - Параметры  в  позволяют изменить  и .
  -  обрабатывает `Retry-After` и 5xx.

**Appendix — важные типы и конфиги**

-  — : таймауты, TTL и concurrency.
- Файлы с ключевой логикой:
  - Aggregation:  — , .
  - Cache factory:  — .
  - Scoring:  — .
  - Reverse/ptr:  — , .
  - Fetch with retry:  — .
  - Sources: lib/sources/* (см. list).

**Явные предположения**
- В репозитории есть рабочие npm-скрипты для dev/test; если их нет — сообщите, я помогу добавить.
- Redis опционален: код корректно падает back to in-memory cache, если  не задан.
- Некоторые адаптеры (SecurityTrails) требуют API-ключи — без них методы вернут [].

Если хотите, могу:
- Сгенерировать полноценный  файл и поместить его в проект.
- Добавить шаги и примеры curl для API.
- Подключить интеграционные тесты для одного пассивного источника (mock).

**Примеры использования API (curl)**

1) Пример запроса проверки домена (`POST /api/check`):

```bash
curl -sS -X POST http://localhost:3000/api/check \
  -H 'Content-Type: application/json' \
  -d '{"domain":"example.com"}'
```

Ожидаемый ответ (пример):

```json
{
  "domain": "example.com",
  "subdomains": [
    {"subdomain":"www.example.com","ips":["93.184.216.34"],"sources":["securitytrails"]},
    {"subdomain":"mail.example.com","ips":[],"sources":["crtsh"]}
  ],
  "total": 2
}
```

2) Пример обратного поиска (`POST /api/reverse`):

```bash
curl -sS -X POST http://localhost:3000/api/reverse \
  -H 'Content-Type: application/json' \
  -d '{"text":"93.184.216.34\n8.8.8.8"}'
```

Ожидаемый ответ (пример):

```json
[
  {"ip":"93.184.216.34","hostnames":["www.example.com"],"error":null},
  {"ip":"8.8.8.8","hostnames":["dns.google"],"error":null}
]
```

3) Переменные окружения (пример для локального запуска с Redis):

```bash
export REDIS_URL=redis://localhost:6379
export REDIS_PASSWORD=""
export PORT=3000
npm run dev
```

---

Файловые ссылки: основная документация сохранена в `docs/TECHNICAL_DOCUMENTATION.md`.
